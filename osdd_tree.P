
/**
  * and_osdd(+OSDD_handle1, +OSDD_handle2, -OSDD_handle):
**/

and_osdd(Oh1, Oh2, Oh) :-
	bin_op(and, Oh1, Oh2, Oh).

/**
  * or_osdd(+OSDD_handle1, +OSDD_handle2, -OSDD_handle):
**/

or_osdd(Oh1, Oh2, Oh) :-
	bin_op(or, Oh1, Oh2, Oh).

/**
  * bin_op logic
**/

bin_op(Op, leaf(1), Oh2, Oh) :- !, bin_op1(Op, Oh2, Oh).
bin_op(Op, leaf(0), Oh2, Oh) :- !, bin_op0(Op, Oh2, Oh).
bin_op(Op, Oh1, leaf(1), Oh) :- !, bin_op1(Op, Oh1, Oh).
bin_op(Op, Oh1, leaf(0), Oh) :- !, bin_op0(Op, Oh1, Oh).

bin_op(Op, tree(R1, E1s), tree(R2, E2s), Oh) :-
	compare(R1, R2, C),
	(C < 0  /* R1 is smaller */
	-> apply_binop(Op, E1s, R2, Es), make_osdd(R1, Es, Oh)
	;   (C > 0 /* R2 is smaller */
	    ->  apply_binop(Op, E2s, R1, Es), make_osdd(R2, Es, Oh)
	    ;	/* R1=R2 */ apply_all_binop(Op, E1s, E2s, Es), make_osdd(R1, Es, Oh)
	    )
	).

bin_op1(and, Oh, Oh).
bin_op1(or, _, leaf(1)).
bin_op0(or, Oh, Oh).
bin_op0(and, _, leaf(0)).

/* Do binop with all trees in list (arg 2) and the other given tree (arg 3) */
:- index apply_binop/4-2.
apply_binop(_Op, [], _Oh2, []).
apply_binop(Op, [edge_subtree(C,Oh1)|E1s], Oh2, [edge_subtree(C,Oh)|Es]) :-
	bin_op(Op, Oh1, Oh2, Oh),
	apply_binop(Op, E1s, Oh2, Es).

/* Do binop, pairwise, for all trees in the two lists (arg 2, and arg 3) */
apply_all_binop(Op, E1s, E2s, Es) :- apply_all_binop(Op, E1s, E2s, [], Es).

:- index apply_all_binop/5-3.
apply_all_binop(_Op, _E1s, [], Es, Es).

apply_all_binop(Op, E1s, [edge_subtree(C2,Oh2)|E2s], Eis, Eos) :-
	apply_1_binop(Op, E1s, C2, Oh2, Eis, Ets),
	apply_all_binop(Op, E1s, E2s, Ets, Eos).

apply_1_binop(Op, [], _C2, _Oh2, Es, Es).
apply_1_binop(Op, [edge_subtree(C1,Oh1)|E1s], C2, Oh2, Eis, Eos) :-
	bin_op(Op, Oh1, Oh2, Oh),
	conjunction(C1, C2, C),
	Eos = [edge_subtree(C, Oh)|Ets],
	apply_1_binop(Op, E1s, C2, Oh2, Ets, Eos).	

make_osdd(R, Eis, Oh) :-
	prune_inconsistent_edges(Eis, Eps),
	(Eps = []
	->  Oh = leaf(0)
	;   order_edges(Eps, Eos),
	    Oh = tree(R, Eos)
	).

/* To be written */
/**
  * compare(R1, R2, C):  C=-1 if R1 is smaller; C=+1 if R2 is smaller; C=0 if R1=R2
  * Note: do this using the id attributes of R1 and R2
**/
compare(R1, R2, 0) :-
    read_id(R1, (S, I)),
    read_id(R2, (S, I)).

compare(R1, R2, -1) :-
    read_id(R1, (S1, I1)),
    read_id(R2, (S2, I2)),
    (I1 @< I2
    ->  true
    ;   (S1 @< S2
    	->  true
    	;   false
    	)
    ).

compare(R1, R2, 1) :-
    read_id(R1, (S1, I1)),
    read_id(R2, (S2, I2)),
    (I1 @> I2
    ->  true
    ;   (S1 @> S2
    	->  true
    	;   false
    	)
    ).

/**
  * conjunction(C1, C2, C):  C is the conjunction of two constraint lists C1 and C2
**/
conjunction(C1, C2, C) :-
    listutil:merge(C1, C2, C).

/**
  * prune_inconsistent_edges(E1s, E2s):  E2s contains only those edges from E1s whose constraints are satisfiable
**/
prune_inconsistent_edges(_, _).

/**
  * order_edges(E1s, E2s): E2s contains all edges in E1s, but ordered in a canonical way
**/
order_edges(_, _).

